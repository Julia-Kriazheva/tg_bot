# В google colab добавить: !pip install pyTelegramBotAPI
# Чтобы добавить новое слово — нужно его прописать в массиве DEFINITOINS на 11 строчке
# Важно все новые аббривиатуры в коде писать только с маленьких букв
# Пользователь в телеграм может писать и с большой и с маленькой — код всегда приводит к строчным

import telebot 
from telebot import TeleBot, types

bot = TeleBot(token='сюда вставь токен', parse_mode='html') # создание бота

# словарь с определениями и аббревиатурами, которые знает бот
# в формате:
# 'ключевая фраза': 'соответствующее ей определение'
DEFINITOINS = {
    'регресс': 'Проверка, что новый функционал не сломал существующий',
    'смоук': 'Проверка самых критичных позитивных кейсов',

    'нагрузочное тестирование': 'Тестирование в пределах значений нагрузки, которые должна выдержать система',
    'стрессовое тестирование': 'Тестирование за пределами значений нагрузки (увеличенное в несколько раз)',
    'rps': 'Request Per Second - единица измерения при нагрузочном тестировании',
    'тест-дизайн': 'Это этап процесса тестирования ПО, на котором проектируются и создаются тестовые случаи (тест кейсы), в соответствии с определёнными ранее критериями качества и целями тестирования',
    'класс эквивалентности': 'Это множество значений, которые при тестировании дают одинаковый результат',
    'граничные значения': 'Это значения, в которых один класс эквивалентности переходит в другой',
    'тестовая документация': 'набор документов, создаваемых перед началом процесса тестирования и непосредственно в процессе (тест план, чек-лист, тест-кейс, баг репорт, отчет о тестировании',
    'тест-кейс': 'Пошаговый сценарий проверки работы системы',
    'Test Suit': 'это наборы тест-кейсов, то есть тест-кейсы, сгруппированные по какому-либо принципу',
    'баг репорт': 'Документ, который содержит в себе полное описание бага, включающее информацию как о самом баге (краткое описание, критичность, приоритет и т. д.), так и об условиях возникновения данного бага',
    'чек-лист': 'Список проверок, которые нужно осуществить на тестируемом ресурсе',
    'тест план': 'Документ, описывающий весь объем работ по тестированию, начиная с описания объекта, стратегии, расписания, критериев начала и окончания тестирования, до необходимого в процессе работы оборудования, специальных знаний, а также оценки рисков с вариантами их разрешения',
    'отчет о тестировании': 'Документ, обобщающий результаты работ по тестированию',
    'TMS': 'Test Management System - система управления тестированием, она позволяет планировать, отслеживать и проверять результат выполнения тестов (например, TestRail, Test IT, Zephyr, Яндекс Пальма, Qase.io)',
    'milestone': 'Цель запуска рана',
    'чит-лист': 'Однотипные проверки для каких-то элементов (например, одинаковые проверки для инпутов)',
    'html': 'HyperText Markup Language - язык разметки документов для просмотра веб-страницы в браузере, служит "каркасом веб-страницы"',
    'css': 'Cascading Style Sheets — формальный язык описания внешнего вида документа (веб-страницы)',
    'git': ' система контроля версий кода',
    'http': 'Hypertext Transfer Protocol - протокол передачи данных',
    'devtools': 'это набор инструментов, встроенных в браузер, для создания и отладки сайтов',
    'rest': 'Архитектурный стиль REST - договоренность, философия, правила этикета о том, как передавать информацию',
    'cUrl': 'формат или инструмент для передачи запросов. в нем содержатся урл, хедеры и боди',
    'json': 'формат данных в body, который поддерживает несколько типов данных: строка, число, boolean, массив, объект, null',
    'клиент': 'визуализация, то, что видит пользователь (например, сайт или приложение)',
    'бекенд': 'это вся логика на сервере, то, что скрыто от глаз пользователя',
    'https': 'протокол безопасной передачи данных, поддерживает технологию шифрования TLS/SSL',
    'tls/ssl': 'протоколы, обеспечивающие защищенную передачу данных в компьютерной сети',
    'квери': 'это составляющая URL начинается с ? и разделяется &, в нем можно передавать параметры на сервер',
    'get': 'запрос для получения данных',
    'post': 'запрос для передачи данных',
    'put': 'запрос на изменение данных',
    'delete': 'запрос на удаление данных',
    'headers': 'Заголовки HTTP позволяют клиенту и серверу отправлять дополнительную информацию (о клиенте или сервере) с HTTP запросом или ответом. В HTTP-заголовке содержится не чувствительное к регистру название, а затем после ( : ) непосредственно значение',
    'куки': 'это хранящиеся на клиенте небольшие файлы, с помощью которых сайт запоминает информацию о посещениях пользователя',
    'api': 'интерфейс взаимодействия программ, который включает в себя методы взаимодействия с сервисами и описание методов',
    'функциональное тестирование': 'определение, насколько компонент или система соответствуют заданным функциональным требованиям, описанным в спецификациях',
    'модульное тестирование': 'проверка корректности работы каждого отдельного компонента ПО (модуля, объекта, функции и пр.)',
    'интеграционное тестирование': 'тестирование логики взаимосвязей между частями продукта, позволяет выявить дефекты, возникшие при объединении модулей',
    'тестирование безопасности': 'тестирование ПО на наличие уязвимостей в безопасности подключений, безопасности данных и безопасности доступа',
    'системное тестирование': 'тестирование функциональности системы на этапах сборки каждой версии продукта, а также на этапе выпуска ПО',
    'тестирование документации': 'проверка предоставленной документации на соответствие определенным требованиям (полнота, отсутствие неточностей и двузначностей, реализуемость проекта и пр.)',
    'тестовое покрытие': 'это «плотность» покрытия тестами выполняемого программного кода ПО или требований к нему',
    'баг': 'дефект, отклонение от ожидаемого поведения системы при тестировании'
}

# обработчик команды '/start'
@bot.message_handler(commands=['start'])
def start_command_handler(message: types.Message):
    # отправляем ответ на команду '/start'
    sti = open('welcome.webp', 'rb')
    bot.send_sticker(message.chat.id, sti) 
    bot.send_message(
        chat_id=message.chat.id, # id чата, в который необходимо направить сообщение
        text='Привет, {0.first_name}! Я помогу тебе расшифровать некоторые айтишные аббревиатуры и термины 🤓\nВведи интересующий термин, например, регресс'.format(message.from_user, bot.get_me()), parse_mode = 'html' # текст сообщения
    )

# обработчик всех остальных сообщений
@bot.message_handler()
def message_handler(message: types.Message):
    # пробуем найти ключевую фразу в словаре
    definition = DEFINITOINS.get(
        message.text.lower(), # приводим текст сообщения к нижнему регистру
    )
    # если фразы нет в словаре, то переменная definition будет иметь значение None
    # проверяем это условие
    if definition is None:
        # если ключевая фраза не была найдена в словаре
        # отправляем ответ
        bot.send_message(
            chat_id=message.chat.id,
            text='😳 Я пока не знаю такого определения',
        )
        # выходим из функции
        return
    
    # если ключевая фраза была найдена, формируем текст сообщения и отправляем его
    # если перед строкой поставить букву f, то в фигурных скобках {} можно использовать переменные :)
    bot.send_message(
        chat_id=message.chat.id,
        text=f'Определение:\n<code>{definition}</code>',
    )

    bot.send_message(
        chat_id=message.chat.id,
        text=f'Жду следующий термин 😉',
    )


# главная функция программы
def main():
    # запускаем нашего бота
    bot.infinity_polling()


if __name__ == '__main__':
    main()
